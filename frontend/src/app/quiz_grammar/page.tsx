// frontend/src/app/quiz_grammar/page.tsx

"use client";

import React, { useState, useEffect, useCallback } from "react"; 
import { useRouter, useSearchParams } from 'next/navigation'; 
import { Loader2 } from "lucide-react"
import { useCountdown } from "../hooks/useCountdown";
import Sidebar from "../test/quiz/components/Sidebar"; 
import QuestionContent from "../test/quiz/components/QuestionContent";
import LoadingModal from "../../components/ui/LoadingModal"; 
import toast from "react-hot-toast"; 

const SUBMIT_API_BASE_URL = 'http://127.0.0.1:8000/api/quiz-grammar'; 

interface Question {
    id: number;
    question_text: string;
    options: string[];
    correct_answer: string; 
}

export default function QuizPage() {
    const router = useRouter();
    const searchParams = useSearchParams(); 
    const sessionId = searchParams.get('sessionId'); 

    const [shuffledQuestions, setShuffledQuestions] = useState<Question[]>([]); 
    const [isLoading, setIsLoading] = useState(true); 
    const [showLoading, setShowLoading] = useState(false);
    const [statusMessage, setStatusMessage] = useState<string>("ƒêang t·∫£i d·ªØ li·ªáu phi√™n l√†m b√†i..."); 
    
    const [currentQuestion, setCurrentQuestion] = useState(1);
    const [selectedOptions, setSelectedOptions] = useState<Record<number, string>>({}); 
    const [currentUserId, setCurrentUserId] = useState<string | null>(null); 
    
    const { minutes, seconds } = useCountdown(10 * 60); 


    // --- LOGIC T·∫¢I C√ÇU H·ªéI V√Ä KI·ªÇM TRA TR·∫†NG TH√ÅI (POLLING LOGIC) ---
    // ‚úÖ THAY ƒê·ªîI: H√†m n√†y tr·∫£ v·ªÅ true ƒë·ªÉ STOP polling n·∫øu th√†nh c√¥ng HO·∫∂C g·∫∑p l·ªói nghi√™m tr·ªçng
    const fetchQuestions = useCallback(async (token: string): Promise<boolean> => {
        if (!sessionId) return true; // D·ª´ng polling n·∫øu kh√¥ng c√≥ session ID
        
        try {
            const response = await fetch(`${SUBMIT_API_BASE_URL}/${sessionId}/questions`, {
                headers: { "Authorization": `Bearer ${token}` }
            });

            if (!response.ok) {
                const errorData = await response.json(); 
                const status = response.status;
                const detail = errorData.detail || `L·ªói ${status}`;

                if (status === 404 || status === 403) {
                    // L·ªói phi√™n kh√¥ng t·ªìn t·∫°i/kh√¥ng c√≥ quy·ªÅn truy c·∫≠p
                    setStatusMessage("Phi√™n l√†m b√†i kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ l·ªói.");
                    toast.error(detail);
                    router.push('/roadmap'); 
                    return true; // üö® STOP POLLING
                }
                
                // üö® FIX L·ªñI 429/500: L·ªói API t·∫°o b√†i
                if (status === 429 || status >= 500) {
                    setStatusMessage("L·ªói m√°y ch·ªß/Quota. Vui l√≤ng th·ª≠ l·∫°i sau.");
                    toast.error(`L·ªói API (${status}): ${detail}`);
                    return true; // üö® STOP POLLING
                }
                
                // L·ªói t·∫°m th·ªùi, ti·∫øp t·ª•c th·ª≠ l·∫°i
                setStatusMessage(`L·ªói k·∫øt n·ªëi (${status}). ƒêang th·ª≠ l·∫°i...`);
                return false; 
            }
            
            const data = await response.json(); 
            const questions = data || [];

            if (questions.length > 0) {
                setShuffledQuestions(questions);
                setStatusMessage("B√†i ki·ªÉm tra ƒë√£ s·∫µn s√†ng!");
                return true; // ‚úÖ TH√ÄNH C√îNG: STOP POLLING
            } else {
                setStatusMessage("The test is being generated by AI. Please wait‚Ä¶");
                return false; // Ch∆∞a s·∫µn s√†ng, ti·∫øp t·ª•c polling
            }

        } catch (e) {
            // L·ªói m·∫°ng ho·∫∑c l·ªói parsing
            setStatusMessage(`L·ªói t·∫£i: ${e instanceof Error ? e.message : 'Kh√¥ng x√°c ƒë·ªãnh'}`);
            // Ch√∫ng ta v·∫´n return false ƒë·ªÉ th·ª≠ l·∫°i sau 5s, tr·ª´ khi c√≥ logic ch·∫∑n kh√°c
            return false; 
        } finally {
            setIsLoading(false);
        }
    }, [sessionId, router]);


    // --- EFFECT CH√çNH: POLLING V√Ä X√ÅC TH·ª∞C ---
    useEffect(() => {
        const userId = localStorage.getItem('authenticatedUserId');
        const token = localStorage.getItem('access_token');
        
        // 1. X√ÅC TH·ª∞C
        if (!userId || !token) {
            toast.error("Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i ƒë·ªÉ l√†m b√†i ki·ªÉm tra.");
            router.push('/auth');
            return;
        }
        setCurrentUserId(userId);

        // 2. POLLING LOGIC
        let interval: NodeJS.Timeout | null = null;
        
        if (sessionId) {
            // L·∫ßn g·ªçi ƒë·∫ßu ti√™n (kh√¥ng c·∫ßn async IIFE v√¨ ƒë√£ c√≥ wrapper)
            fetchQuestions(token); 
            
            interval = setInterval(async () => {
                const finished = await fetchQuestions(token);
                if (finished) {
                    // ‚úÖ NG·ª™NG POLLING khi th√†nh c√¥ng ho·∫∑c g·∫∑p l·ªói nghi√™m tr·ªçng (429/500)
                    clearInterval(interval!); 
                }
            }, 5000); 
            
        } else {
            toast.error("Thi·∫øu ID b√†i ki·ªÉm tra.");
            router.push('/roadmap'); 
            setIsLoading(false);
        }
        
        return () => {
            if (interval) clearInterval(interval);
        };
        
    }, [router, sessionId, fetchQuestions]); // Th√™m fetchQuestions v√†o dependency


    const handleSubmit = async () => {
        // ... (Logic handleSubmit gi·ªØ nguy√™n) ...
        if (!currentUserId || !sessionId || shuffledQuestions.length === 0) {
            toast.error("B√†i l√†m kh√¥ng h·ª£p l·ªá ho·∫∑c l·ªói x√°c th·ª±c.");
            return;
        }
        
        setShowLoading(true);
        const token = localStorage.getItem('access_token');
        
        const mcqAnswers: Record<number, string> = {}; 

        Object.entries(selectedOptions).forEach(([qId, answer]) => {
            if (typeof answer === 'string' && answer !== null) {
                mcqAnswers[parseInt(qId)] = answer; 
            } 
        });

        const payload = {
            session_id: parseInt(sessionId), 
            user_id: currentUserId,
            answers: mcqAnswers, 
        };
        
        // --- G·ª≠i Submission ---
        try {
            toast.loading("ƒêang ch·∫•m ƒëi·ªÉm v√† c·∫≠p nh·∫≠t ti·∫øn ƒë·ªô...", { id: 'analysis-loading' });

            const response = await fetch(`${SUBMIT_API_BASE_URL}/${sessionId}/submit`, { 
                method: 'POST',
                headers: { "Content-Type": "application/json", "Authorization": `Bearer ${token}` },
                body: JSON.stringify(payload)
            });
            
            toast.dismiss('analysis-loading');

            if (!response.ok) {
                const errorData = await response.json(); 
                throw new Error(errorData.detail || `L·ªói Server ${response.status}.`);
            }

            const results = await response.json(); 
            
            toast.success(`N·ªôp b√†i ho√†n t·∫•t! ƒêi·ªÉm c·ªßa b·∫°n: ${(results.score_percent * 100).toFixed(0)}%.`);
            
            setTimeout(() => {
               router.push(`/quiz_grammar/results?sessionId=${sessionId}`);
            }, 800);

        } catch (error) {
            let errorMessage = 'G·ª≠i b√†i l√†m th·∫•t b·∫°i.';
            if (error instanceof Error) { errorMessage = error.message; }
            
            toast.dismiss('analysis-loading');
            toast.error(`L·ªói: ${errorMessage}`);
        } finally {
            setShowLoading(false);
        }
    };
    
    // Logic Loading / Status Message
    if (isLoading || shuffledQuestions.length === 0) {
        return (
            <div className="min-h-screen flex items-center justify-center bg-gray-50">
                <div className="text-center">
                    {/* ‚úÖ HI·ªÇN TH·ªä SPINNER khi ƒëang t·∫£i */}
                    {isLoading && <Loader2 className="w-8 h-8 animate-spin mx-auto mb-3 text-blue-500" />} 
                    <p className="text-lg text-gray-600">
                        {statusMessage} 
                    </p>
                </div>
            </div>
        );
    }
    
    const currentQ = shuffledQuestions[currentQuestion - 1];
    const currentAnswer = selectedOptions[currentQ?.id] || null; 

    return (
        <main className="min-h-screen bg-gray-50 py-8 px-6">
            {showLoading && (
                <LoadingModal
                    title="Grading and Analyzing..."
                    message="Evaluating your results and updating progress. Please wait."
                />
            )}

            <div className="flex max-w-7xl mx-auto gap-6">
                
                {/* Sidebar */}
                <Sidebar
                    shuffledQuestions={shuffledQuestions}
                    currentQuestion={currentQuestion}
                    selectedOptions={selectedOptions}
                    setCurrentQuestion={setCurrentQuestion}
                    minutes={minutes}
                    seconds={seconds}
                    onSubmit={handleSubmit}
                />

                {/* Question Area */}
                <div className="flex-1 flex justify-center">
                    <QuestionContent
                        currentQ={currentQ}
                        currentAnswer={currentAnswer}
                        setSelectedOptions={setSelectedOptions as any}
                        currentQuestion={currentQuestion}
                    />
                </div>

            </div>
        </main>
    );
}